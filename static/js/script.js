// Application state
let flashcardsData = [];
let hasSavedCurrentSet = false;

document.addEventListener('DOMContentLoaded', function() {
    console.log('AI Study Buddy loaded successfully!');
    
    // Initialize card flip functionality
    const flashcardElements = document.querySelectorAll('.flashcard');
    flashcardElements.forEach(card => {
        card.addEventListener('click', function() {
            this.classList.toggle('flipped');
        });
    });
    
    // Generate flashcards button
    const generateBtn = document.getElementById('generate-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', generateFlashcards);
    }
    
    // Save flashcards button
    const saveBtn = document.getElementById('save-btn');
    if (saveBtn) {
        saveBtn.addEventListener('click', saveFlashcards);
    }
});

// Generate flashcards function
function generateFlashcards() {
    // Reset save state when generating new flashcards
    hasSavedCurrentSet = false;
    
    const notes = document.getElementById('study-notes').value;
    const count = parseInt(document.getElementById('num-questions').value);
    
    if (!notes) {
        alert('Please enter some study notes first.');
        return;
    }
    
    if (count < 1 || count > 10) {
        alert('Please enter a number between 1 and 9 for the number of questions.');
        return;
    }
    
    // Show loading animation
    const loader = document.getElementById('loader');
    const generateBtn = document.getElementById('generate-btn');
    const saveBtn = document.getElementById('save-btn');
    
    loader.style.display = 'block';
    generateBtn.disabled = true;
    
    // Send request to backend
    fetch('/generate_questions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            notes: notes,
            num_questions: count
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            flashcardsData = data.questions.map(q => ({
                ...q,
                userAnswer: null,
                answered: false
            }));
            
            displayFlashcards();
            
            // Enable save button for new flashcards
            saveBtn.disabled = false;
            saveBtn.textContent = 'Save Flashcards';
            hasSavedCurrentSet = false;
            saveBtn.title = 'Save these flashcards to your study history';
            
            // Show AI status message
            const statusMessage = document.getElementById('ai-status');
            if (statusMessage) {
                statusMessage.textContent = data.message || 
                    (data.source === 'ai' ? 'Questions generated by AI' : 'Using sample questions');
                statusMessage.className = `ai-status ${data.source}`;
            }
            
        } else {
            alert('Error generating questions: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error generating questions');
    })
    .finally(() => {
        loader.style.display = 'none';
        generateBtn.disabled = false;
    });
}

// Update Save Button state function definition
function updateSaveButtonState() {
    const saveBtn = document.getElementById('save-btn');
    if (!saveBtn) return;
    
    if (hasSavedCurrentSet) {
        // Already saved current set - keep disabled
        saveBtn.disabled = true;
        saveBtn.textContent = '✓ Saved';
        saveBtn.title = 'Flashcards saved! Generate new flashcards to save another set.';
    } else if (flashcardsData && flashcardsData.length > 0) {
        // Have flashcards, check if all are answered
        const unanswered = flashcardsData.filter(card => 
            card.userAnswer === null || card.userAnswer === undefined
        ).length;
        
        saveBtn.disabled = unanswered > 0;
        saveBtn.textContent = 'Save Flashcards';
        saveBtn.title = unanswered > 0 ? 
            `Please answer all ${unanswered} questions before saving` : 
            'Save these flashcards to your study history';
    } else {
        // No flashcards generated yet
        saveBtn.disabled = true;
        saveBtn.textContent = 'Save Flashcards';
        saveBtn.title = 'Generate flashcards first';
    }
}

// Function to set uniform card heights
function setUniformCardHeights() {
    const flashcards = document.querySelectorAll('.flashcard');
    let maxHeight = 0;
    
    // First reset heights to auto to get accurate measurements
    flashcards.forEach(card => {
        card.style.height = 'auto';
    });
    
    // Find the maximum height
    flashcards.forEach(card => {
        const front = card.querySelector('.flashcard-front');
        const back = card.querySelector('.flashcard-back');
        
        // Use the taller of the two sides
        const cardHeight = Math.max(
            front.scrollHeight, 
            back.scrollHeight
        );
        
        if (cardHeight > maxHeight) {
            maxHeight = cardHeight;
        }
    });
    
    // Add some padding to the max height
    maxHeight += 20;
    
    // Apply the maximum height to all cards
    flashcards.forEach(card => {
        card.style.height = `${maxHeight}px`;
    });
}

// Display flashcards function
function displayFlashcards() {
    const flashcardsContainer = document.getElementById('flashcards-container');
    const scoreContainer = document.getElementById('score-container');
    
    flashcardsContainer.innerHTML = '';
    scoreContainer.textContent = 'Score: 0/0 (0%)';
    
    flashcardsData.forEach((card, index) => {
        const flashcardEl = document.createElement('div');
        flashcardEl.className = 'flashcard';
        flashcardEl.setAttribute('data-index', index);
        
        flashcardEl.innerHTML = `
            <div class="flashcard-inner">
                <div class="flashcard-front">
                    <div class="question">${card.question}</div>
                    <div class="options">
                        ${card.options.map((option, optIndex) => `
                            <div class="option" data-option="${optIndex}">
                                ${String.fromCharCode(65 + optIndex)}) ${option}
                            </div>
                        `).join('')}
                    </div>
                    <div class="instructions">Select an answer, then click to flip</div>
                </div>
                <div class="flashcard-back">
                    <div class="question">${card.question}</div>
                    <div class="feedback" id="feedback-${index}"></div>
                    <div class="instructions">Click to return to question</div>
                </div>
            </div>
        `;
        
        flashcardsContainer.appendChild(flashcardEl);
        
        // Add event listeners for option selection
        const optionEls = flashcardEl.querySelectorAll('.option');
        optionEls.forEach(optionEl => {
            optionEl.addEventListener('click', function(e) {
                e.stopPropagation();
                const cardIndex = parseInt(flashcardEl.getAttribute('data-index'));
                const optionIndex = parseInt(this.getAttribute('data-option'));
                selectAnswer(cardIndex, optionIndex);
            });
        });
        
        // Add flip functionality
        flashcardEl.addEventListener('click', function() {
            const cardIndex = parseInt(this.getAttribute('data-index'));
            const card = flashcardsData[cardIndex];
            
            if (card.userAnswer === null) {
                alert('Please select an answer first.');
                return;
            }
            
            if (!card.answered) {
                card.answered = true;
                updateCardUI(cardIndex);
                updateScore();
                flashcardEl.classList.add('revealed');
            }
            
            this.classList.toggle('flipped');
        });
    });
    setTimeout(setUniformCardHeights, 100);
    updateSaveButtonState();
}

// Handle answer selection
function selectAnswer(cardIndex, optionIndex) {
    const card = flashcardsData[cardIndex];
    if (card.answered) return;
    
    card.userAnswer = optionIndex;
    
    const flashcardEl = document.querySelector(`.flashcard[data-index="${cardIndex}"]`);
    const optionEls = flashcardEl.querySelectorAll('.option');
    
    optionEls.forEach(el => el.classList.remove('selected'));
    optionEls[optionIndex].classList.add('selected');
}

// Function whenever answers change
function selectAnswer(cardIndex, optionIndex) {
    const card = flashcardsData[cardIndex];
    if (card.answered) return;
    
    card.userAnswer = optionIndex;
    
    const flashcardEl = document.querySelector(`.flashcard[data-index="${cardIndex}"]`);
    const optionEls = flashcardEl.querySelectorAll('.option');
    
    optionEls.forEach(el => el.classList.remove('selected'));
    optionEls[optionIndex].classList.add('selected');
    
    // Update save button state when answers change
    updateSaveButtonState();
}

// Update card UI after answer is revealed
function updateCardUI(cardIndex) {
    const card = flashcardsData[cardIndex];
    const flashcardEl = document.querySelector(`.flashcard[data-index="${cardIndex}"]`);
    const optionEls = flashcardEl.querySelectorAll('.option');
    const feedbackEl = document.getElementById(`feedback-${cardIndex}`);
    
    optionEls.forEach((el, index) => {
        if (index === card.correctAnswer) {
            el.classList.add('correct');
        }
        if (index === card.userAnswer) {
            if (index === card.correctAnswer) {
                el.classList.add('correct');
                feedbackEl.textContent = "Correct! ✅";
                feedbackEl.className = "feedback correct";
            } else {
                el.classList.add('incorrect');
                feedbackEl.textContent = "Incorrect! ❌";
                feedbackEl.className = "feedback incorrect";
            }
        }
    });
}

// Update score function
function updateScore() {
    const answeredCount = flashcardsData.filter(card => card.answered).length;
    const totalCount = flashcardsData.length;
    
    if (answeredCount < totalCount) {
        // Show progress, not score
        document.getElementById('score-container').textContent = 
            `Progress: ${answeredCount}/${totalCount} answered`;
    } else {
        // All answered, show actual score
        const correctCount = flashcardsData.filter(card => 
            card.userAnswer === card.correctAnswer
        ).length;
        const percentage = Math.round((correctCount / totalCount) * 100);
        document.getElementById('score-container').textContent = 
            `Score: ${correctCount}/${totalCount} (${percentage}%)`;
    }
}

// Save flashcards function
function saveFlashcards() {
    // Prevent saving if already saved
    if (hasSavedCurrentSet) {
        alert('These flashcards have already been saved. Generate new flashcards to save another set.');
        return;
    }
    
    const notes = document.getElementById('study-notes').value;
    
    if (flashcardsData.length === 0) {
        alert('No flashcards to save! Please generate some flashcards first.');
        return;
    }
    
    const unanswered = flashcardsData.filter(card => card.userAnswer === null);
    if (unanswered.length > 0) {
        alert(`Please answer all ${unanswered.length} unanswered questions before saving.`);
        return;
    }

    const unrevealed = flashcardsData.filter(card => !card.answered).length;
    if (unrevealed > 0) {
        alert(`Please reveal all ${unrevealed} answers before saving.`);
        return;
    }
    
    const saveBtn = document.getElementById('save-btn');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;
    
    fetch('/save_flashcards', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            flashcards: flashcardsData,
            notes: notes
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Mark as saved and update UI
            hasSavedCurrentSet = true;
            saveBtn.disabled = true;
            saveBtn.textContent = '✓ Saved';
            saveBtn.title = 'Flashcards saved! Generate new flashcards to save another set.';
            
            alert('Flashcards saved successfully!');
            console.log('Session ID:', data.session_id);
            
        } else {
            alert('Error saving flashcards: ' + data.message);
            saveBtn.disabled = false;
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error saving flashcards');
        saveBtn.disabled = false;
    })
    .finally(() => {
        if (!hasSavedCurrentSet) {
            saveBtn.textContent = originalText;
        }
    });
}

// Load saved sessions from backend
// Load saved sessions from backend
function loadSessions() {
    console.log('🔍 Loading sessions from /list_sessions...');
    
    fetch('/list_sessions')
        .then(response => {
            console.log('📥 Response received, status:', response.status, response.statusText);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('📊 Sessions data received:', data);
            
            if (data.status === 'success') {
                console.log(`✅ Found ${data.sessions.length} sessions`);
                renderSessions(data.sessions);
            } else {
                console.error('❌ Error loading sessions:', data.message);
                // Show error message to user
                const container = document.getElementById('sessions-container');
                container.innerHTML = `<p class="error">Error loading sessions: ${data.message}</p>`;
            }
        })
        .catch(error => {
            console.error('❌ Error fetching sessions:', error);
            // Show error message to user
            const container = document.getElementById('sessions-container');
            container.innerHTML = `<p class="error">Failed to load sessions. Please check console for details.</p>`;
        });
}

// Render sessions in the UI
function renderSessions(sessions) {
    const container = document.getElementById('sessions-container');
    container.innerHTML = '';

    // Safety check - ensure sessions is an array
    if (!Array.isArray(sessions)) {
        console.error('❌ renderSessions expected array but got:', sessions);
        container.innerHTML = '<p class="error">Invalid session data format</p>';
        return;
    }

    if (sessions.length === 0) {
        container.innerHTML = '<p>No saved sessions yet.</p>';
        return;
    }

    const list = document.createElement('ul');
    list.className = 'sessions-list';

    sessions.forEach(session => {
        const item = document.createElement('li');
        item.className = 'session-item';

        item.innerHTML = `
            <div>
                <div class="session-topic">${session.title}</div>
                <div class="session-date">${new Date(session.created_at).toLocaleString()}</div>
            </div>
            <span class="session-questions" title="Total questions">${session.total_questions}</span>
            <span class="session-score" title="Score percentage">${session.score_percentage}%</span>
            <button class="delete-session-btn" data-id="${session.id}">Delete</button>
        `;

        list.appendChild(item);
    });

    container.appendChild(list);

    // Attach delete listeners
    const deleteButtons = container.querySelectorAll('.delete-session-btn');
    deleteButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const sessionId = btn.getAttribute('data-id');
            deleteSession(sessionId);
        });
    });
}

// Delete a session
function deleteSession(sessionId) {
    if (!confirm("Are you sure you want to delete this session?")) return;

    fetch(`/delete_session/${sessionId}`, { method: 'DELETE' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                loadSessions(); // refresh after delete
            } else {
                alert('Error deleting session: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error deleting session:', error);
            alert('Error deleting session');
        });
}

// Load sessions on page load
document.addEventListener('DOMContentLoaded', loadSessions);

// Pagination state
let currentPage = 1;
const sessionsPerPage = 5;
let allSessions = [];

// Load saved sessions with pagination
function loadSessions(page = 1) {
    console.log('🔍 Loading sessions from /list_sessions...');
    currentPage = page;
    
    fetch('/list_sessions')
        .then(response => {
            console.log('📥 Response received, status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('📊 Sessions data received:', data);
            
            if (data.status === 'success') {
                allSessions = data.sessions;
                console.log(`✅ Found ${allSessions.length} total sessions`);
                renderPaginatedSessions();
            } else {
                console.error('❌ Error loading sessions:', data.message);
                const container = document.getElementById('sessions-container');
                container.innerHTML = `<p class="error">Error loading sessions: ${data.message}</p>`;
            }
        })
        .catch(error => {
            console.error('❌ Error fetching sessions:', error);
            const container = document.getElementById('sessions-container');
            container.innerHTML = `<p class="error">Failed to load sessions. Please check console for details.</p>`;
        });
}

// Render paginated sessions
function renderPaginatedSessions() {
    const container = document.getElementById('sessions-container');
    const startIndex = (currentPage - 1) * sessionsPerPage;
    const endIndex = startIndex + sessionsPerPage;
    const paginatedSessions = allSessions.slice(startIndex, endIndex);
    
    renderSessions(paginatedSessions);
    renderPaginationControls();
}

// Render pagination controls
function renderPaginationControls() {
    const totalPages = Math.ceil(allSessions.length / sessionsPerPage);
    const paginationContainer = document.getElementById('pagination-controls');
    
    if (allSessions.length <= sessionsPerPage) {
        paginationContainer.innerHTML = '';
        return;
    }
    
    paginationContainer.innerHTML = `
        <button class="pagination-btn" onclick="loadSessions(${currentPage - 1})" 
                ${currentPage === 1 ? 'disabled' : ''}>
            ← Previous
        </button>
        
        <span class="pagination-info">
            Page ${currentPage} of ${totalPages} (${allSessions.length} total sessions)
        </span>
        
        <button class="pagination-btn" onclick="loadSessions(${currentPage + 1})" 
                ${currentPage === totalPages ? 'disabled' : ''}>
            Next →
        </button>
    `;
}

// Fuction to ender Sessions
function renderSessions(sessions) {
    const container = document.getElementById('sessions-container');
    container.innerHTML = '';

    if (!Array.isArray(sessions)) {
        console.error('❌ renderSessions expected array but got:', sessions);
        container.innerHTML = '<p class="error">Invalid session data format</p>';
        return;
    }

    if (sessions.length === 0) {
        if (currentPage > 1) {
            container.innerHTML = '<p>No more sessions on this page.</p>';
        } else {
            container.innerHTML = '<p>No saved sessions yet.</p>';
        }
        return;
    }

    const list = document.createElement('ul');
    list.className = 'sessions-list';

    sessions.forEach(session => {
        const item = document.createElement('li');
        item.className = 'session-item';

        item.innerHTML = `
            <div class="session-content">
                <div class="session-topic">${session.title}</div>
                <div class="session-date">${new Date(session.created_at).toLocaleString()}</div>
            </div>
            <div class="session-stats">
                <div class="session-stat session-questions">
                    <span class="session-stat-label">Questions:</span>
                    <span class="session-stat-value">${session.total_questions}</span>
                </div>
                <div class="session-stat session-score">
                    <span class="session-stat-label">Score:</span>
                    <span class="session-stat-value">${session.score_percentage}%</span>
                </div>
            </div>
            <button class="delete-session-btn" data-id="${session.id}">Delete</button>
        `;

        list.appendChild(item);
    });

    container.appendChild(list);

    // Attach delete listeners
    const deleteButtons = container.querySelectorAll('.delete-session-btn');
    deleteButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const sessionId = btn.getAttribute('data-id');
            deleteSession(sessionId);
        });
    });
}

// Filter sessions by search term
function filterSessions(searchTerm) {
    if (!searchTerm.trim()) {
        renderPaginatedSessions();
        return;
    }
    
    const filtered = allSessions.filter(session => 
        session.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
        session.created_at.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    renderSessions(filtered.slice(0, sessionsPerPage));
    
    // Hide pagination when searching
    document.getElementById('pagination-controls').innerHTML = 
        filtered.length > 0 ? 
        `<p>Showing ${filtered.length} matching sessions</p>` : 
        `<p>No sessions match "${searchTerm}"</p>`;
}

// Update delete function to refresh pagination
function deleteSession(sessionId) {
    if (!confirm("Are you sure you want to delete this session?")) return;

    fetch(`/delete_session/${sessionId}`, { method: 'DELETE' })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Reload sessions but stay on current page
                loadSessions(currentPage);
            } else {
                alert('Error deleting session: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error deleting session:', error);
            alert('Error deleting session');
        });
}

// Update DOMContentLoaded to include pagination
document.addEventListener('DOMContentLoaded', function() {
    loadSessions(1); // Load first page initially
});